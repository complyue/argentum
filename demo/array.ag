using sys { Object; Array; }
// Extends sys_Array with:
// * Amortized insertions
// * iterations
// * producer-style assignments
class sys_Array{
    itemsCount = 0;

    size() int { itemsCount }

    each((Object)void handler) {
        i = 0;
        loop!{
            i < itemsCount ? {
                this[i] ? handler(_);
                i += 1
            }
        }
    }
    plow((Object)bool filter) {
        i = 0;
        loop!{
            i < itemsCount ? {
                this[i] && filter(_)
                    ? { i += 1; }
                    : deleteAt(i);
            }
        }
    }
    deleteAt(int i) {
        sys_setAtArray(this, i, ?sys_Object);
        sys_moveItems(this, i, i + 1, itemsCount);
        itemsCount -= 1;
    }
    push(int n, (int)?@Object generator) {
        itemsCount + n >= sys_getSize(this)
            ? sys_insertItems(this, itemsCount, (itemsCount + n + 20) / 4);
        loop{
            sys_setAtArray(this, itemsCount, generator(itemsCount));
            itemsCount += 1;
            (n -= 1) == 0
        }
    }
    setAt(int i, ()@Object generator) bool {
        i < itemsCount ? sys_setAtArray(this, i, generator())
    }
    append(()@Object provider) ?Object {
        push(1, (i){ provider() });
        this[itemsCount - 1]
    }
}

class sys_WeakArray{
    size() int { sys_getSize(this) }
    resize(int n) this { sys_insertItems(this, 0, n) }
    append(?Object item) ?Object {
        n = size();
        sys_insertItems(this, n, 1);
        setAt(n, item)
    }
    setAt(int n, ?Object item) ?Object {
        item ? sys_setAtWeakArray(this, n, &_);
        item
    }
}

test insertIntoArray() {
    a = Array;
    a.push(2, (i){ ?Object });
    a.size() != 2 ? sys_terminate(-1)
}
